# Server
===============================

Copyright (c) 2025 Joe Teglasi. License: MIT

* KEYWORDS: server, app, router, http, https

A stripped-down, but still "batteries-included", server implementation based on the [server.js](https://serverjs.io) npm module, designed for Espruino. 

## Summary & Structure

Server is one of the fastest ways to get a web-app up and running. The module provides 3 components:

- `server`: this is the main function that starts the server. It also contains the other 2 components as props. 
- `server.router`: this collection contains the routing functions for each request method
- `server.ServerReply`: the ServerReply class enables chainable methods for building an http response


## Quick Start

### Hello World
```js
server = require('server.js')

//start a server on the default port (80), and respond to any request at any path with "Hello World"
server(
    ctx => "Hello World"
)
```

### Simple Routing

```js
server = require('server.js')
const get = server.router.get;

server(
    get('/hello', ctx => "World"),
    get('/goodnight', ctx => "Moon")
)
```

### Set Status and Headers
```js
server = require('server.js')
const get = server.router.get;

server(
    ctx=>{
        //we can set headers here, and it will be included in the ServerReply for any reply returned in subsequent Middleware or RouteHandlers
        ctx.responseHeaders = {
            "Access-Control-Allow-Origin": "*",
            "X-Application-Timestamp": Date.now().toString()
        }
    },
    get('/', ctx => SOME_WEBPAGE_HTML), //set SOME_WEBPAGE_HTML to whatever you want
    get('/no-headers', ctx => {
        return new server.ServerReply(ctx).status(200).headers({}).send("We set headers to {} (empty) for this route only")
    })
)
```

### Query Params
For any requests, if there is a query-string in the URL, it will be parsed and stored in `ctx.query`.

### Handling Request Data
For `PUT` and `POST` requests, the request body is stored in `ctx.body`, which is aliased at `ctx.data` as well.

```js
server = require('server.js')
const post = server.router.post;

server(
    post('/', ctx => {
        console.log("Got data:", ctx.body)
        return "Thanks for the data: " + ctx.body
    }),
)
```

### Performance and Optimization on Espruino
Espruino has a couple quirks that relate to performance (see: https://www.espruino.com/Performance). These lead to the following (non-exhaustive) list of optimizations.

#### Syntax & Structure

1. Use ServerReply implicitly by returning primitives (or Promises that resolve to primitives). (Access to the ServerReply class is provided to enable similar syntax to the `server` npm module's `server.reply`. Using ServerReply explicitly results in clearer syntax, but more overhead in terms of flash memory, and possibly execution).

2. Set the http status code with `ctx.statusCode = code` instead of `new server.ServerReply(ctx).status(code)...`. 

3. Set common headers in one Middleware using `ctx.responseHeaders=commonHeaders` early on in MiddlewareAndRoutes instead of returning `new server.ServerReply(ctx).headers(commonHeaders)...` as part of every RouteHandler. If you need to add additional headers for certain RouteHandlers, prefer `Object.assign(ctx.responseHeaders, routeHeaders)`.

4. Avoid deeply nested MiddlewareAndRoutes, as these are handled recursively and could cause crashes if it exceeds the microcontroller's limits.

#### RAM

The following performance modifications can be made if you have enough RAM:

5. For your most frequently called Middleware functions, you may want to add the special `"ram";` string at the top of the funciton body to instruct Espruino to keep it in RAM, so that it doesn't need to be executed from flash every time it is called.

## API

### server
The `server` function can be called with either of two signatures:
```js
//simple usage, will use default port. See ServerParams
server(...middlewareAndRoutes: MiddlewareAndRoutes[])

//or specify ServerParams
server(options: ServerParams, ...middlewareAndRoutes: MiddlewareAndRoutes[])
```

```ts
ServerParams {
  PORT?: number //defaults to process.env.PORT || 80
}
```

Note: Calling `server(...)` returns the instance of the `httpSrv` generated by the Espruino 'http' module, but in general it is unnecessary to assign the return value to a variable for standard usage of this module.

### Middleware

Middleware are functions that take a single `ctx: RequestContext` param, and either return a value or undefined.

```ts
type Middleware = (ctx: RequestContext): undefined|string|number|array|object|ServerReply

interface RequestContext extends httpSRq {
    req: httpSRq; // The original HTTP server-request object
    res: httpSRs; // The original HTTP server-response object
    path: string; // The request path
    params: Record<string, string>; //an object containing any parsed route-params. See Routes and Params for more details
    query: Record<string, any>; //The parsed query parameters
    
    /** 
     * A promise that resolves to the request body (for POST/PUT requests).
     * As per Espruino documentation, request body must be a string.
     * If there is no body provided, or it times-out, it resolves to false.
     */
    body?: Promise<string | false>;
    data?: Promise<string | false>; //Alias for body 
}
```

Middleware are used in two ways:
1. They can be passed directly to the `server()` call. They will be executed in the order they are specified.
2. They can be used as part of a RouteHandler, in which case they will only execute if the requested url matches the RouteHandler's `route`.

### server.ServerReply

The ServerReply class is used for sending http responses from Middleware and RouteHandlers.

The easiest way to use it is *implicitly*: If any Middleware or RouteHandler returns a value, and that value isn't already a ServerReply instance, then the `server` module will automatically generate a ServerReply internally. Objects and Arrays will be automatically stringified. All other values will be sent as strings.

A ServerReply instance can also be used explicitly as the return value. In some cases, it may be clearer what the status code and headers are, and more similar to the `server` npm package's syntax.

NOTE: This is one difference between the `server` npm package and this Espruino module. 

```js
//The npm  module has syntax like:
return server.reply.status(200).send('some response text') //will NOT work on Espruino


// The Espruino module requires the equivalent syntax:
return new server.ServerReply(ctx).status(200).send('some response text') //works on Espruino

//server.reply is an alias for server.ServerReply, and can also be used:
return new server.reply(ctx).status(200).send('some response text') //works on Espruino

//When using implicit ServerReply, you can set the statusCode and headers as follows:
ctx.statusCode = 200
ctx.responseHeaders = {"Access-Control-Allow-Origin": "*"}
return "some response text"
```

```ts
declare class ServerReply {
    constructor(ctx: RequestContext): ServerReply;
    status(code: number): ServerReply; //set the response status code
    headers(pairs: Record<string,string>): ServerReply; //set the response headers
    send(str: string): ServerReply; // send a string as the response body
    json(data: object|array): ServerReply; //JSON.stringify data and send it as the response body
}
```

### server.router

`server.router` contains the ServerRouter class, which contains the following static methods for creating `RouteHandler` instances:

```ts
declare class ServerRouter {
    static get(route: string, func: Middleware): RouteHandler;
    static put(route: string, func: Middleware): RouteHandler;
    static post(route: string, func: Middleware): RouteHandler;
    static del(route: string, func: Middleware): RouteHandler;
}
```

### RouteHandler

A `RouteHandler` is essentially a Middleware funciton that only executes if the requested path matches its `route` property

```ts
interface RouteHandler extends Middleware {
    route: string;
}
```

### MiddlewareAndRoutes

`MiddlewareAndRoutes` can be described as the following type:

```ts
type MiddlewareAndRoutes = Middleware | RouteHandler | MiddlewareAndRoutes[]
```

It can be composed in many ways. Some examples:

```js
server([
    ctx => {
        console.log('got a request: ', ctx.method, ctx.path)
    },
    get('/', ctx => {
        if (ctx.query.allowed) {
            return "You are allowed to access url: '/'";
        } else {
            return new server.ServerReply(ctx).status(401).send("Forbidden.")
        }
    }),
    get('/home', ctx => {
        return "<h1>Home is where the heart is</h1>"
    }),
    [
        ctx => {
            console.log("If you see this message, the requested path was not '/' and not '/home'")
        }
        get('/count', ctx=>{
            if (!process.count) process.count = 0;
            return process.count
        })
        put('/count', ctx=>{
            process.count = parseInt(ctx.body)||0
            return process.count
        })
        post('/count', ctx=>{
            if (!process.count) process.count = 0;
            process.count++;
            return process.count
        })
        del('/count', ctx=>{
            process.count = 0
            return process.count
        })
    ],
    ctx=>{
        return new server.ServerReply(ctx).status(404).send("No route matched")
    }
])
```

If we execute the following requests in sequence, we will get the following logs and output

```js

fetch('http://<server-ip>/').then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: GET /"
//client console: [401, "Forbidden."]

fetch('http://<server-ip>/?allowed=true').then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: GET /"
//client console: [200, "You are allowed to access url: '/'"]

fetch('http://<server-ip>/home').then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: GET /home"
//client console: [200, "<h1>Home is where the heart is</h1>"]

fetch('http://<server-ip>/count').then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: GET /count"
//server console: "If you see this message, the requested path was not '/' and not '/home'"
//client console: [200, "0"]

fetch('http://<server-ip>/count',{
    method: 'PUT',
    body: '5'
}).then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: PUT /count"
//server console: "If you see this message, the requested path was not '/' and not '/home'"
//client console: [200, "5"]

fetch('http://<server-ip>/count',{
    method: 'POST',
}).then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: POST /count"
//server console: "If you see this message, the requested path was not '/' and not '/home'"
//client console: [200, "6"]

fetch('http://<server-ip>/count',{
    method: 'DELETE',
}).then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: DELETE /count"
//server console: "If you see this message, the requested path was not '/' and not '/home'"
//client console: [200, "0"]

fetch('http://<server-ip>/not-a-route').then(r=>[r.status, r.text()]).then(console.log)
//server console: "got a request: GET /not-a-route"
//server console: "If you see this message, the requested path was not '/' and not '/home'"
//client console: [404, "No route matched"]

```

### Routes and Route-Params

When checking if a requested path matches a RouteHandler's `route`, if the route contains a route-parameter (e.g.`/:paramName`) in it, then the part of the path that contains that route-parameter will be treated as the value for the route-parameter, and will be included in the `RequestContext` under `RequestContext.params`. 

For example:
If we have the following `RequestHandler` and users object

```js
const users = {
    "123": "Jane Smith"
}
server(
    get('/users/:id/name', ctx=>{
        const userId = ctx.params.id
        return status(200).send(`The name of User with id="${userId}" is: "${users[userId]}"`)
    })
)
```
If we send the following request:
```js
fetch('http://localhost/users/123/name').then(r=>r.text()).then(console.log)

// output: 
// The name of user with id="123" is: "Jane Smith"
```

### Environmental Variables
The following internals of the module check for env variables as defaults.

`process.env.PORT` - (Default: `80`) Used by server() as the default port to listen on if `serverParams.PORT` is not provided.

`process.env.REQ_BODY_TIMEOUT` - (Default: `5e3`) Used by RequestContext to wait for the body of a PUT or POST request to resolve, after which the body will resolve to `false`. Value is in ms.

